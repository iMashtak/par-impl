use lalrpop_util::ErrorRecovery;

use arcstr::ArcStr;

use crate::ast::*;
use crate::tokens::{Token, LexicalError};

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token, LexicalError>>);

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "__error" => Token::Error,

        "native" => Token::Native,
        "def" => Token::Def,
        "type" => Token::Type,
        "let" => Token::Let,
        "recv" => Token::Recv,
        "either" => Token::Either,
        "case" => Token::Case,
        "choice" => Token::Choice,
        "chan" => Token::Chan,
        "dual" => Token::Dual,
        "recursive" => Token::Recursive,
        "iterative" => Token::Iterative,
        "box" => Token::Box,
        "self" => Token::Self_,
        "begin" => Token::Begin,
        "loop" => Token::Loop,
        "in" => Token::In,
        "try" => Token::Try,
        "catch" => Token::Catch,
        "throw" => Token::Throw,
        "do" => Token::Do,
        "unfounded" => Token::Unfounded,
        "and" => Token::And,
        "or" => Token::Or,
        "not" => Token::Not,
        "break" => Token::Break,

        "!" => Token::Unit,
        "?" => Token::Question,
        ":" => Token::Colon,
        ";" => Token::Semicolon,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LCurly,
        "}" => Token::RCurly,
        "<>" => Token::Link,
        "<" => Token::Lt,
        ">" => Token::Gt,
        "<=" => Token::Le,
        ">=" => Token::Ge,
        "," => Token::Comma,
        "." => Token::Dot,
        "/" => Token::Slash,
        "=" => Token::Eq,
        "==" => Token::EqEq,
        "!=" => Token::NotEq,
        "=>" => Token::DoubleArrow,
        "->" => Token::Arrow,
        "<-" => Token::ReverseArrow,
        "*" => Token::Star,
        "-" => Token::Minus,
        "+" => Token::Plus,
        "%" => Token::Percent,
        "@" => Token::Amp,
        "::" => Token::DoubleColon,
        "'" => Token::SingleQuote,

        "str" => Token::Str(<ArcStr>),
        "i32" => Token::I32(<i32>),
        "u64" => Token::U64(<u64>),

        "global_ident" => Token::GlobalIdent(<ArcStr>),
        "local_ident" => Token::LocalIdent(<ArcStr>),

        "comment" => Token::Comment(<ArcStr>),
    }
}

// ---
// File root
// ---

pub Program: Program 
    = <l: @L> <defs: Definition*> <r: @R> 
    => Program {defs, l, r};

Definition: Definition = {
    <l: @L> "native" "def" <name: GlobalIdent> <r: @R> => Definition::Native {name, l, r},
    <l: @L> "def" <name: GlobalIdent> "=" <expr: ProcessExpr> <r: @R> => Definition::ProcessExpr {name, expr, l, r},
};

// ---
// Process Syntax
// ---

ProcessStep: ProcessStep = {
    <l: @L> "let" <name: LocalIdent> "=" <expr: ProcessExpr> <r: @R> => ProcessStep::Let {name, expr, l, r},
    <l: @L> <target: LocalIdent> "<>" <expr: ProcessExpr> <r: @R> => ProcessStep::Link {target, expr, l, r},
    <l: @L> <target: LocalIdent> "." "begin" <label: Label?> "{" <steps: ProcessStep*> "}" <r: @R>
        => ProcessStep::Begin {target, label, steps, l, r},
    <l: @L> <target: LocalIdent> "." "case" "{" <alts: Comma<CaseBranch>> "}" <r: @R> => ProcessStep::Case {target, alts, l, r},
    <l: @L> <target: LocalIdent> "[" <name: LocalIdent> "]" <r: @R> => ProcessStep::Recv {target, name, l, r},
    <l: @L> <target: LocalIdent> "(" <expr: ProcessExpr> ")" <r: @R> => ProcessStep::Send {target, expr, l, r},
    <l: @L> <target: LocalIdent> "." <signal: LocalIdent> <r: @R> => ProcessStep::Signal {target, signal, l, r},
    <l: @L> "loop" <label: Label?> <r: @R> => ProcessStep::Loop {label, l, r},
    <l: @L> "break" <label: Label?> <r: @R> => ProcessStep::Break {label, l, r},
};

ProcessExpr: ProcessExpr = {
    <l: @L> "chan" <name: LocalIdent> "{" <steps: ProcessStep+> "}" <r: @R> => ProcessExpr::Chan {name, steps, l, r},
    <l: @L> <x: "str"> <r: @R> => ProcessExpr::Str {value: x, l, r},
    <l: @L> <x: "i32"> <r: @R> => ProcessExpr::I32 {value: x, l, r},
    <l: @L> <x: "u64"> <r: @R> => ProcessExpr::U64 {value: x, l, r},
    <l: @L> <x: Ident> <r: @R> => ProcessExpr::Ident {value: x, l, r},
    <l: @L> "!" <r: @R> => ProcessExpr::Unit {l, r},
};

CaseBranch: CaseBranch
    = <l: @L> "." <name: LocalIdent> "=>" "{" <inner: ProcessStep*> "}" <r: @R>
    => CaseBranch {name, inner, l, r};

// ---
// Primitives
// ---

Label: Label
    = <l: @L> "@" <name: LocalIdent> <r: @R>
    => Label {name, l, r};
GlobalIdent: GlobalIdent
    = <l: @L> <content: "global_ident"> <r: @R>
    => GlobalIdent {content, l, r};
LocalIdent: LocalIdent
    = <l: @L> <content: "local_ident"> <r: @R>
    => LocalIdent {content, l, r};
Ident: Ident = {
    <x: GlobalIdent> => Ident::Global(x),
    <x: LocalIdent> => Ident::Local(x),
};
Comment: Comment
    = <l: @L> <content: "comment"> <r: @R>
    => Comment {content, l, r };

// ---
// Macros
// ---

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
